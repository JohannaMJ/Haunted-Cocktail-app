// node_modules/haunted/lib/interface.js
var current;
var currentId = 0;
function setCurrent(state) {
  current = state;
}
function clear() {
  current = null;
  currentId = 0;
}
function notify() {
  return currentId++;
}

// node_modules/haunted/lib/symbols.js
var phaseSymbol = Symbol("haunted.phase");
var hookSymbol = Symbol("haunted.hook");
var updateSymbol = Symbol("haunted.update");
var commitSymbol = Symbol("haunted.commit");
var effectsSymbol = Symbol("haunted.effects");
var layoutEffectsSymbol = Symbol("haunted.layoutEffects");
var contextEvent = "haunted.context";

// node_modules/haunted/lib/hook.js
var Hook = class {
  id;
  state;
  constructor(id, state) {
    this.id = id;
    this.state = state;
  }
};
function use(Hook2, ...args) {
  let id = notify();
  let hooks = current[hookSymbol];
  let hook2 = hooks.get(id);
  if (!hook2) {
    hook2 = new Hook2(id, current, ...args);
    hooks.set(id, hook2);
  }
  return hook2.update(...args);
}
function hook(Hook2) {
  return use.bind(null, Hook2);
}

// node_modules/haunted/lib/use-memo.js
var useMemo = hook(class extends Hook {
  value;
  values;
  constructor(id, state, fn, values) {
    super(id, state);
    this.value = fn();
    this.values = values;
  }
  update(fn, values) {
    if (this.hasChanged(values)) {
      this.values = values;
      this.value = fn();
    }
    return this.value;
  }
  hasChanged(values = []) {
    return values.some((value, i) => this.values[i] !== value);
  }
});

// node_modules/haunted/lib/use-ref.js
function useRef(initialValue) {
  return useMemo(() => ({
    current: initialValue
  }), []);
}

export {
  setCurrent,
  clear,
  phaseSymbol,
  hookSymbol,
  updateSymbol,
  commitSymbol,
  effectsSymbol,
  layoutEffectsSymbol,
  contextEvent,
  Hook,
  hook,
  useMemo,
  useRef
};
//# sourceMappingURL=chunk-FW2K6F7L.js.map
