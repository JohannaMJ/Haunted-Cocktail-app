{
  "version": 3,
  "sources": ["../../haunted/lib/interface.js", "../../haunted/lib/symbols.js", "../../haunted/lib/hook.js", "../../haunted/lib/use-memo.js", "../../haunted/lib/use-ref.js"],
  "sourcesContent": ["let current;\nlet currentId = 0;\nfunction setCurrent(state) {\n    current = state;\n}\nfunction clear() {\n    current = null;\n    currentId = 0;\n}\nfunction notify() {\n    return currentId++;\n}\nexport { clear, current, setCurrent, notify };\n", "const phaseSymbol = Symbol(\"haunted.phase\");\nconst hookSymbol = Symbol(\"haunted.hook\");\nconst updateSymbol = Symbol(\"haunted.update\");\nconst commitSymbol = Symbol(\"haunted.commit\");\nconst effectsSymbol = Symbol(\"haunted.effects\");\nconst layoutEffectsSymbol = Symbol(\"haunted.layoutEffects\");\nconst contextEvent = \"haunted.context\";\nexport { phaseSymbol, hookSymbol, updateSymbol, commitSymbol, effectsSymbol, layoutEffectsSymbol, contextEvent, };\n", "import { current, notify } from \"./interface\";\nimport { hookSymbol } from \"./symbols\";\nclass Hook {\n    id;\n    state;\n    constructor(id, state) {\n        this.id = id;\n        this.state = state;\n    }\n}\nfunction use(Hook, ...args) {\n    let id = notify();\n    let hooks = current[hookSymbol];\n    let hook = hooks.get(id);\n    if (!hook) {\n        hook = new Hook(id, current, ...args);\n        hooks.set(id, hook);\n    }\n    return hook.update(...args);\n}\nfunction hook(Hook) {\n    return use.bind(null, Hook);\n}\nexport { hook, Hook };\n", "import { hook, Hook } from \"./hook\";\n/**\n * @function\n * @template T\n * @param  {() => T} fn function to memoize\n * @param  {unknown[]} values dependencies to the memoized computation\n * @return {T} The next computed value\n */\nconst useMemo = hook(class extends Hook {\n    value;\n    values;\n    constructor(id, state, fn, values) {\n        super(id, state);\n        this.value = fn();\n        this.values = values;\n    }\n    update(fn, values) {\n        if (this.hasChanged(values)) {\n            this.values = values;\n            this.value = fn();\n        }\n        return this.value;\n    }\n    hasChanged(values = []) {\n        return values.some((value, i) => this.values[i] !== value);\n    }\n});\nexport { useMemo };\n", "import { useMemo } from \"./use-memo\";\nexport function useRef(initialValue) {\n    return useMemo(() => ({\n        current: initialValue,\n    }), []);\n}\n"],
  "mappings": ";AAAA,IAAI;AACJ,IAAI,YAAY;AAChB,SAAS,WAAW,OAAO;AACvB,YAAU;AACd;AACA,SAAS,QAAQ;AACb,YAAU;AACV,cAAY;AAChB;AACA,SAAS,SAAS;AACd,SAAO;AACX;;;ACXA,IAAM,cAAc,OAAO,eAAe;AAC1C,IAAM,aAAa,OAAO,cAAc;AACxC,IAAM,eAAe,OAAO,gBAAgB;AAC5C,IAAM,eAAe,OAAO,gBAAgB;AAC5C,IAAM,gBAAgB,OAAO,iBAAiB;AAC9C,IAAM,sBAAsB,OAAO,uBAAuB;AAC1D,IAAM,eAAe;;;ACJrB,IAAM,OAAN,MAAW;AAAA,EACP;AAAA,EACA;AAAA,EACA,YAAY,IAAI,OAAO;AACnB,SAAK,KAAK;AACV,SAAK,QAAQ;AAAA,EACjB;AACJ;AACA,SAAS,IAAIA,UAAS,MAAM;AACxB,MAAI,KAAK,OAAO;AAChB,MAAI,QAAQ,QAAQ,UAAU;AAC9B,MAAIC,QAAO,MAAM,IAAI,EAAE;AACvB,MAAI,CAACA,OAAM;AACP,IAAAA,QAAO,IAAID,MAAK,IAAI,SAAS,GAAG,IAAI;AACpC,UAAM,IAAI,IAAIC,KAAI;AAAA,EACtB;AACA,SAAOA,MAAK,OAAO,GAAG,IAAI;AAC9B;AACA,SAAS,KAAKD,OAAM;AAChB,SAAO,IAAI,KAAK,MAAMA,KAAI;AAC9B;;;ACdA,IAAM,UAAU,KAAK,cAAc,KAAK;AAAA,EACpC;AAAA,EACA;AAAA,EACA,YAAY,IAAI,OAAO,IAAI,QAAQ;AAC/B,UAAM,IAAI,KAAK;AACf,SAAK,QAAQ,GAAG;AAChB,SAAK,SAAS;AAAA,EAClB;AAAA,EACA,OAAO,IAAI,QAAQ;AACf,QAAI,KAAK,WAAW,MAAM,GAAG;AACzB,WAAK,SAAS;AACd,WAAK,QAAQ,GAAG;AAAA,IACpB;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,WAAW,SAAS,CAAC,GAAG;AACpB,WAAO,OAAO,KAAK,CAAC,OAAO,MAAM,KAAK,OAAO,CAAC,MAAM,KAAK;AAAA,EAC7D;AACJ,CAAC;;;ACzBM,SAAS,OAAO,cAAc;AACjC,SAAO,QAAQ,OAAO;AAAA,IAClB,SAAS;AAAA,EACb,IAAI,CAAC,CAAC;AACV;",
  "names": ["Hook", "hook"]
}
