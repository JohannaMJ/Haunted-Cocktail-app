import {
  Hook,
  clear,
  commitSymbol,
  contextEvent,
  effectsSymbol,
  hook,
  hookSymbol,
  layoutEffectsSymbol,
  phaseSymbol,
  setCurrent,
  updateSymbol,
  useMemo,
  useRef
} from "./chunk-FW2K6F7L.js";
import {
  _$LH,
  html,
  noChange,
  render
} from "./chunk-HFNPXFKU.js";

// node_modules/haunted/lib/state.js
var State = class {
  update;
  host;
  virtual;
  [hookSymbol];
  [effectsSymbol];
  [layoutEffectsSymbol];
  constructor(update, host) {
    this.update = update;
    this.host = host;
    this[hookSymbol] = /* @__PURE__ */ new Map();
    this[effectsSymbol] = [];
    this[layoutEffectsSymbol] = [];
  }
  run(cb) {
    setCurrent(this);
    let res = cb();
    clear();
    return res;
  }
  _runEffects(phase) {
    let effects = this[phase];
    setCurrent(this);
    for (let effect of effects) {
      effect.call(this);
    }
    clear();
  }
  runEffects() {
    this._runEffects(effectsSymbol);
  }
  runLayoutEffects() {
    this._runEffects(layoutEffectsSymbol);
  }
  teardown() {
    let hooks = this[hookSymbol];
    hooks.forEach((hook2) => {
      if (typeof hook2.teardown === "function") {
        hook2.teardown();
      }
    });
  }
};

// node_modules/haunted/lib/scheduler.js
var defer = Promise.resolve().then.bind(Promise.resolve());
function runner() {
  let tasks = [];
  let id;
  function runTasks() {
    id = null;
    let t = tasks;
    tasks = [];
    for (var i = 0, len = t.length; i < len; i++) {
      t[i]();
    }
  }
  return function(task) {
    tasks.push(task);
    if (id == null) {
      id = defer(runTasks);
    }
  };
}
var read = runner();
var write = runner();
var BaseScheduler = class {
  renderer;
  host;
  state;
  [phaseSymbol];
  _updateQueued;
  constructor(renderer, host) {
    this.renderer = renderer;
    this.host = host;
    this.state = new State(this.update.bind(this), host);
    this[phaseSymbol] = null;
    this._updateQueued = false;
  }
  update() {
    if (this._updateQueued)
      return;
    read(() => {
      let result = this.handlePhase(updateSymbol);
      write(() => {
        this.handlePhase(commitSymbol, result);
        write(() => {
          this.handlePhase(effectsSymbol);
        });
      });
      this._updateQueued = false;
    });
    this._updateQueued = true;
  }
  handlePhase(phase, arg) {
    this[phaseSymbol] = phase;
    switch (phase) {
      case commitSymbol:
        this.commit(arg);
        this.runEffects(layoutEffectsSymbol);
        return;
      case updateSymbol:
        return this.render();
      case effectsSymbol:
        return this.runEffects(effectsSymbol);
    }
  }
  render() {
    return this.state.run(() => this.renderer.call(this.host, this.host));
  }
  runEffects(phase) {
    this.state._runEffects(phase);
  }
  teardown() {
    this.state.teardown();
  }
};

// node_modules/haunted/lib/component.js
var toCamelCase = (val = "") => val.replace(/-+([a-z])?/g, (_, char) => char ? char.toUpperCase() : "");
function makeComponent(render2) {
  class Scheduler2 extends BaseScheduler {
    frag;
    constructor(renderer, frag, host) {
      super(renderer, host || frag);
      this.frag = frag;
    }
    commit(result) {
      render2(result, this.frag);
    }
  }
  function component2(renderer, baseElementOrOptions, options) {
    const BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;
    const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {} } = options || baseElementOrOptions || {};
    class Element extends BaseElement {
      _scheduler;
      static get observedAttributes() {
        return renderer.observedAttributes || observedAttributes || [];
      }
      constructor() {
        super();
        if (useShadowDOM === false) {
          this._scheduler = new Scheduler2(renderer, this);
        } else {
          this.attachShadow({ mode: "open", ...shadowRootInit });
          this._scheduler = new Scheduler2(renderer, this.shadowRoot, this);
        }
      }
      connectedCallback() {
        this._scheduler.update();
      }
      disconnectedCallback() {
        this._scheduler.teardown();
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue) {
          return;
        }
        let val = newValue === "" ? true : newValue;
        Reflect.set(this, toCamelCase(name), val);
      }
    }
    function reflectiveProp(initialValue) {
      let value = initialValue;
      let isSetup = false;
      return Object.freeze({
        enumerable: true,
        configurable: true,
        get() {
          return value;
        },
        set(newValue) {
          if (isSetup && value === newValue)
            return;
          isSetup = true;
          value = newValue;
          if (this._scheduler) {
            this._scheduler.update();
          }
        }
      });
    }
    const proto = new Proxy(BaseElement.prototype, {
      getPrototypeOf(target) {
        return target;
      },
      set(target, key, value, receiver) {
        let desc;
        if (key in target) {
          desc = Object.getOwnPropertyDescriptor(target, key);
          if (desc && desc.set) {
            desc.set.call(receiver, value);
            return true;
          }
          Reflect.set(target, key, value, receiver);
          return true;
        }
        if (typeof key === "symbol" || key[0] === "_") {
          desc = {
            enumerable: true,
            configurable: true,
            writable: true,
            value
          };
        } else {
          desc = reflectiveProp(value);
        }
        Object.defineProperty(receiver, key, desc);
        if (desc.set) {
          desc.set.call(receiver, value);
        }
        return true;
      }
    });
    Object.setPrototypeOf(Element.prototype, proto);
    return Element;
  }
  return component2;
}

// node_modules/haunted/lib/create-effect.js
function createEffect(setEffects2) {
  return hook(class extends Hook {
    callback;
    lastValues;
    values;
    _teardown;
    constructor(id, state, ignored1, ignored2) {
      super(id, state);
      setEffects2(state, this);
    }
    update(callback, values) {
      this.callback = callback;
      this.values = values;
    }
    call() {
      const hasChanged = !this.values || this.hasChanged();
      this.lastValues = this.values;
      if (hasChanged) {
        this.run();
      }
    }
    run() {
      this.teardown();
      this._teardown = this.callback.call(this.state);
    }
    teardown() {
      if (typeof this._teardown === "function") {
        this._teardown();
      }
    }
    hasChanged() {
      return !this.lastValues || this.values.some((value, i) => this.lastValues[i] !== value);
    }
  });
}

// node_modules/haunted/lib/use-effect.js
function setEffects(state, cb) {
  state[effectsSymbol].push(cb);
}
var useEffect = createEffect(setEffects);

// node_modules/haunted/lib/use-context.js
var useContext = hook(class extends Hook {
  Context;
  value;
  _ranEffect;
  _unsubscribe;
  constructor(id, state, _) {
    super(id, state);
    this._updater = this._updater.bind(this);
    this._ranEffect = false;
    this._unsubscribe = null;
    setEffects(state, this);
  }
  update(Context) {
    if (this.state.virtual) {
      throw new Error("can't be used with virtual components");
    }
    if (this.Context !== Context) {
      this._subscribe(Context);
      this.Context = Context;
    }
    return this.value;
  }
  call() {
    if (!this._ranEffect) {
      this._ranEffect = true;
      if (this._unsubscribe)
        this._unsubscribe();
      this._subscribe(this.Context);
      this.state.update();
    }
  }
  _updater(value) {
    this.value = value;
    this.state.update();
  }
  _subscribe(Context) {
    const detail = { Context, callback: this._updater };
    this.state.host.dispatchEvent(new CustomEvent(contextEvent, {
      detail,
      bubbles: true,
      cancelable: true,
      composed: true
      // to pass ShadowDOM boundaries
    }));
    const { unsubscribe = null, value } = detail;
    this.value = unsubscribe ? value : Context.defaultValue;
    this._unsubscribe = unsubscribe;
  }
  teardown() {
    if (this._unsubscribe) {
      this._unsubscribe();
    }
  }
});

// node_modules/haunted/lib/create-context.js
function makeContext(component2) {
  return (defaultValue) => {
    const Context = {
      Provider: class extends HTMLElement {
        listeners;
        _value;
        constructor() {
          super();
          this.listeners = /* @__PURE__ */ new Set();
          this.addEventListener(contextEvent, this);
        }
        disconnectedCallback() {
          this.removeEventListener(contextEvent, this);
        }
        handleEvent(event) {
          const { detail } = event;
          if (detail.Context === Context) {
            detail.value = this.value;
            detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);
            this.listeners.add(detail.callback);
            event.stopPropagation();
          }
        }
        unsubscribe(callback) {
          this.listeners.delete(callback);
        }
        set value(value) {
          this._value = value;
          for (let callback of this.listeners) {
            callback(value);
          }
        }
        get value() {
          return this._value;
        }
      },
      Consumer: component2(function({ render: render2 }) {
        const context = useContext(Context);
        return render2(context);
      }, { useShadowDOM: false }),
      defaultValue
    };
    return Context;
  };
}

// node_modules/haunted/lib/use-callback.js
var useCallback = (fn, inputs) => useMemo(() => fn, inputs);

// node_modules/haunted/lib/use-layout-effect.js
function setLayoutEffects(state, cb) {
  state[layoutEffectsSymbol].push(cb);
}
var useLayoutEffect = createEffect(setLayoutEffects);

// node_modules/haunted/lib/use-state.js
var useState = hook(class extends Hook {
  args;
  constructor(id, state, initialValue) {
    super(id, state);
    this.updater = this.updater.bind(this);
    if (typeof initialValue === "function") {
      const initFn = initialValue;
      initialValue = initFn();
    }
    this.makeArgs(initialValue);
  }
  update() {
    return this.args;
  }
  updater(value) {
    const [previousValue] = this.args;
    if (typeof value === "function") {
      const updaterFn = value;
      value = updaterFn(previousValue);
    }
    if (Object.is(previousValue, value)) {
      return;
    }
    this.makeArgs(value);
    this.state.update();
  }
  makeArgs(value) {
    this.args = Object.freeze([value, this.updater]);
  }
});

// node_modules/haunted/lib/use-controller.js
var microtask = Promise.resolve();
var HauntedControllerHost = class {
  count;
  kick;
  _controllers = [];
  _updatePending = true;
  _updateCompletePromise;
  _resolveUpdate;
  constructor(count, kick) {
    this.count = count;
    this.kick = kick;
    this._updateCompletePromise = new Promise((res) => {
      this._resolveUpdate = res;
    });
  }
  addController(controller) {
    this._controllers.push(controller);
  }
  removeController(controller) {
    this._controllers && this._controllers.splice(this._controllers.indexOf(controller) >>> 0, 1);
  }
  requestUpdate() {
    if (!this._updatePending) {
      this._updatePending = true;
      microtask.then(() => this.kick(this.count += 1));
    }
  }
  get updateComplete() {
    return this._updateCompletePromise;
  }
  connected() {
    this._controllers.forEach((c) => c.hostConnected && c.hostConnected());
  }
  disconnected() {
    this._controllers.forEach((c) => c.hostDisconnected && c.hostDisconnected());
  }
  update() {
    this._controllers.forEach((c) => c.hostUpdate && c.hostUpdate());
  }
  updated() {
    this._updatePending = false;
    const resolve = this._resolveUpdate;
    this._updateCompletePromise = new Promise((res) => {
      this._resolveUpdate = res;
    });
    this._controllers.forEach((c) => c.hostUpdated && c.hostUpdated());
    resolve(this._updatePending);
  }
};
function useController(createController) {
  const [count, kick] = useState(0);
  const [host] = useState(() => {
    const host2 = new HauntedControllerHost(count, kick);
    const controller = createController(host2);
    host2.primaryController = controller;
    host2.connected();
    return host2;
  });
  useLayoutEffect(() => host.updated());
  useLayoutEffect(() => () => host.disconnected(), []);
  host.update();
  return host.primaryController;
}

// node_modules/haunted/lib/use-reducer.js
var useReducer = hook(class extends Hook {
  reducer;
  currentState;
  constructor(id, state, _, initialState, init) {
    super(id, state);
    this.dispatch = this.dispatch.bind(this);
    this.currentState = init !== void 0 ? init(initialState) : initialState;
  }
  update(reducer) {
    this.reducer = reducer;
    return [this.currentState, this.dispatch];
  }
  dispatch(action) {
    this.currentState = this.reducer(this.currentState, action);
    this.state.update();
  }
});

// node_modules/haunted/lib/core.js
function haunted({ render: render2 }) {
  const component2 = makeComponent(render2);
  const createContext2 = makeContext(component2);
  return { component: component2, createContext: createContext2 };
}

// node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
var directive = (c) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c,
  values
});
var Directive = class {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
};

// node_modules/lit-html/development/directive-helpers.js
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && window.ShadyDOM?.inUse && window.ShadyDOM?.noPatch === true ? window.ShadyDOM.wrap : (node) => node;
var isSingleExpression = (part) => part.strings === void 0;

// node_modules/lit-html/development/async-directive.js
var DEV_MODE = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    obj["_$notifyDirectiveConnectionChanged"]?.(isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while (children?.size === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ??= notifyChildPartConnectedChanged;
    obj._$reparentDisconnectables ??= reparentDisconnectables;
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        this.reconnected?.();
      } else {
        this.disconnected?.();
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/haunted/lib/virtual.js
var includes = Array.prototype.includes;
var partToScheduler = /* @__PURE__ */ new WeakMap();
var schedulerToPart = /* @__PURE__ */ new WeakMap();
var Scheduler = class extends BaseScheduler {
  args;
  setValue;
  constructor(renderer, part, setValue) {
    super(renderer, part);
    this.state.virtual = true;
    this.setValue = setValue;
  }
  render() {
    return this.state.run(() => this.renderer.apply(this.host, this.args));
  }
  commit(result) {
    this.setValue(result);
  }
  teardown() {
    super.teardown();
    let part = schedulerToPart.get(this);
    partToScheduler.delete(part);
  }
};
function makeVirtual() {
  function virtual2(renderer) {
    class VirtualDirective extends AsyncDirective {
      cont;
      constructor(partInfo) {
        super(partInfo);
        this.cont = void 0;
      }
      update(part, args) {
        this.cont = partToScheduler.get(part);
        if (!this.cont || this.cont.renderer !== renderer) {
          this.cont = new Scheduler(renderer, part, (r) => {
            this.setValue(r);
          });
          partToScheduler.set(part, this.cont);
          schedulerToPart.set(this.cont, part);
          teardownOnRemove(this.cont, part);
        }
        this.cont.args = args;
        this.cont.update();
        return this.render(...args);
      }
      render(...args) {
        return noChange;
      }
    }
    return directive(VirtualDirective);
  }
  return virtual2;
}
function teardownOnRemove(cont, part, node = part.startNode) {
  let frag = node.parentNode;
  let mo = new MutationObserver((mutations) => {
    for (let mutation of mutations) {
      if (includes.call(mutation.removedNodes, node)) {
        mo.disconnect();
        if (node.parentNode instanceof ShadowRoot) {
          teardownOnRemove(cont, part);
        } else {
          cont.teardown();
        }
        break;
      } else if (includes.call(mutation.addedNodes, node.nextSibling)) {
        mo.disconnect();
        teardownOnRemove(cont, part, node.nextSibling || void 0);
        break;
      }
    }
  });
  mo.observe(frag, { childList: true });
}

// node_modules/haunted/lib/lit-haunted.js
var { component, createContext } = haunted({ render });
var virtual = makeVirtual();
export {
  BaseScheduler,
  Hook,
  State,
  component,
  createContext,
  haunted as default,
  hook,
  html,
  render,
  useCallback,
  useContext,
  useController,
  useEffect,
  useLayoutEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
  virtual
};
/*! Bundled license information:

haunted/lib/use-controller.js:
  (**
   * @license
   * Portions Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive.js:
lit-html/development/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=haunted.js.map
